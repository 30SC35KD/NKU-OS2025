# Lab5：用户进程管理
## （小组成员：2312289刘轩麟 2312114李子恒 2213468陈馨颍）
## 练习1: 加载应用程序并执行（需要编码）
do_execv函数调用load_icode来加载并解析一个处于内存中的ELF执行文件格式的应用程序，我们需要在load_icode里补充部分代码。首先我们看一下这个函数做了什么：
1. 创建新的 mm 结构体和页目录表（PDT），进行内存结构初始化
1. 检查ELF是否合法
1. 遍历 ELF 可加载段，创建虚拟内存区域（vma），分配物理页，复制 TEXT/DATA 段内容，将 BSS 段初始化为 0
1. 为用户栈分配虚拟内存空间，并预分配 4 个物理页
1. 绑定当前进程的 mm、页目录物理地址，更新 satp 寄存器
1. 设置好proc_struct结构中的成员变量trapframe中的内容

可以看到，代码中需要我们补充的就是trapframe中寄存器的状态维护，我们需要分别维护**用户进程的栈指针sp**、**epc寄存器**和**status寄存器**。
1. 设置sp为用户栈的顶部地址，我们直接用memlayout.h中定义的宏**USTACKTOP**实现。用户栈是进程运行时用于存储局部变量、函数调用信息等的内存区域
1. 设置用户态进程的程序计数器（epc）为ELF文件的入口点地址**elf->e_entry**，这时用户进程的起始执行地址
1. 状态寄存器的设置需要用到原本保存的状态寄存器的值sstatus，我们要保留其基础的状态，仅对个别位进行调整，我们首先对~SSTATUS_SPP进行与操作，意思是对**SPP**那一位清零，其他位保存。因为SPP 位用于标识**上一次的特权级别**，1 表示上一级是内核态，0 表示上一级是用户态，清除该位后，CPU 从内核态返回时会进入用户态；接着我们对**SSTATUS_SPIE**进行或操作，意思是把SPIE那一位置1，SPIE 位用于控制**返回后是否开启中断**，1 表示恢复到用户态后允许响应中断，0 则禁用，所以我们希望用户态程序运行时能正常处理中断。

代码如下：
```c
    tf->gpr.sp = USTACKTOP;
    tf->epc = elf->e_entry;
    tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
    ret = 0;
```

## 练习2：父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程
中（子进程），完成内存资源的复制。具体是通过copy_range函数实现的，在这个函数中，已经找到源页对应的物理页page，并为目标进程分配新的物理页npage。接下来需要我们做的就是将源物理页的虚拟地址内容，完整拷贝到目标物理页的虚拟地址，这就需要我们用page2kva来实现物理地址到虚拟地址的转换。在拷贝完成之后，还需要将目标物理页与目标进程的线性地址建立映射，我们使用page_insert实现。代码如下：
```c
        void *src_kvaddr = page2kva(page); // 获取源页面的内核虚拟地址
        void *dst_kvaddr = page2kva(npage); // 获取目标页面的内核虚拟地址
        memcpy(dst_kvaddr, src_kvaddr, PGSIZE); // 复制页面内容
                
        int ret = page_insert(to, npage, start, perm); // 将目标页面插入到目标进程的页表中
```

关于COW机制，我们在Challenge部分进行讨论。

## 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
接下来我们分析fork/exec/wait/exit的执行流程。总的来说，这些函数在用户程序中被调用，因此在用户进程需要为函数的调用准备参数，发起调用请求。具体调用的就是do_*()函数。
1. fork：
如果用户调用fork()，定义在用户态ulib文件中的fork()会调用sys_fork()，而用户态sys_fork是库函数的封装，会通过ecall发起系统调用：返回 syscall(SYS_fork())。至此进程就**从用户级升级到了内核级**，后面再查表 dispatch，SYS_fork()会调用内核的sys_fork(arg)函数，该函数在内核的syscall目录的syscall.c文件定义，它把父进程的trapframe和当前的用户栈指针拿过来，传给do_fork()。do_fork()才真正调用一系列内核级工具来实现进程的复制。
do_fork 先分配并初始化子进程的内核结构、复制/共享父进程的内存、把父的寄存器上下文复制给子（并把子的 a0寄存器 设为 0），然后把子插入进程表并标记为可运行；父进程立即得到子 PID，子进程在后续被调度时返回 0。

2. execv：
在指导手册中我们学习了第一个用户进程的创建，正是调用了方法execv。该方法目前只在内核中使用。所以在用户态库中没有封装。本次实验中，user_main调用了kernel_execev将我们编写的exit程序代替user_main继续执行。我们在kernel_execev函数中使用ebreak来模拟中断，以此来确保进程的上下文与状态可以顺利切换。他就像一个用户态程序一样，通过syscall查表调用do_execve，但本质上CPU状态级一致没有切换。sys_exec(arg) 从 arg[] 取出四个参数（程序名指针、名字长度、binary 指针、binary 大小），直接调用内核实现 do_execve(name,len,binary,size) 去做真正的加载/替换用户空间工作。
do_execev就是把当前进程的用户空间完全拆掉，按 ELF 给它穿上一个全新的用户空间和栈，然后把寄存器（epc/sp/status）设置好，最后从新程序入口继续运行——进程身份（PID 等）不变，但运行的程序彻底变成新的 ELF。如果执行成功那么execev不会返回，失败才会返回。

3. wait：
wait的封装思路基本和fork类似。例如在exit.c中我们调用wait()，wait()将调用用户态的sys_wait()，通过ecall发起系统调用，触发一个中断。此时切换为内核级进行操作，在syscall中进行查表找到内核级的sys__wait函数，它会解析子进程pid和退出码，然后传给do_wait。
do_wait 就是父进程去看它的孩子们有没有“变成僵尸”——有的话就把子进程的**退出码读出来**，把子进程的内核资源彻底收回；没有的话，要么直接报没有子进程的错误，要么把自己sleep，等孩子退出，再回来处理。

4. exit：
同样在exit.c中我们调用了exit()，后续和前面的调用流程一样，不再赘述，直到内核级的sys_wait函数，它把退出错误码传给do_exit。
do_exit 就是把进程从“活着”变成“僵尸”并把该做的清理工作做好（回收用户内存、保存退出码、把子女交给 init、唤醒父进程），然后让出 CPU 给别人，等待父进程来彻底回收它的内核资源。
ucore中一个用户态进程的执行状态生命周期图如下：

![](figure/用户进程状态图.jpg)
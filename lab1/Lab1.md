# 练习一
在操作系统的内核启动流程中，Qemu会先在芯片硬件设计的初始复位地址执行写死的固定指令，完成基础的环境准备，接着会将控制权移交给OpenSBI。OpenSBI就是RISC-V架构下的“BIOS类似物”（皆可称为boot loader），它会将我们内核镜像文件加载到固定的位置，当PC走到这个位置时，CPU的控制权自然而然就从OpenSBI转移到了我们的OS内核了。但这个过程中，由于操作系统的复杂性要远大于前面的“控制者”，所以这个控制权转移的过程也不简单。在本练习中，我们将分析代码文件`kern/init/entry.S` 是如何引导系统进入内核环境的。

## 1. `la sp, bootstacktop`
首先，la sp, bootstacktop 这条指令将内核栈的顶部地址（即bootstacktop）加载到栈指针寄存器 sp 中。栈指针 sp 是操作系统中管理栈的关键寄存器，指示当前栈的位置。内核栈 bootstack 在内核启动时会被初始化并设置在内存中的一块特定区域，通常是从高地址向低地址增长。通过这条指令，内核确保栈指针指向栈的顶部，为后续内核执行提供了必要的栈空间。

## 2. `tail kern_init`
接着，tail kern_init 指令的作用是将程序的控制权交给内核初始化函数 kern_init，并确保执行完该函数后不会返回。tail 是一种优化指令，能够减少栈帧的创建和销毁，提升程序的效率。在内核启动过程中，kern_init 函数负责执行内核的初始化任务，包括初始化内核数据结构、硬件设置以及其他关键组件。通过使用 tail 指令，内核保证了启动过程的流畅性，且不再回到之前的代码，确保了内核初始化的顺利进行。

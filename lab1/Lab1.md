## 练习2
我们使用tmux打开终端复用会话，这样我们就可以开启两个窗口，一边运行QEMU，一边运行GDB。

使用 `Ctrl+B+%` 垂直分割两个窗格，左边输入 `make debug`，意为打开1234端口，为我们启动GDB调试作准备。

在右侧窗格输入`make gdb`后，我们发现这其实是`riscv64-unknown-elf-gdb`执行了多个操作：
1. `file bin/kernel`：加载编译好的内核文件
1. `set arch riscv:rv64`：调试的是 **RISC-V 64位**的程序
2. `target remote localhost:1234`：去连接本机（localhost）的1234端口，QEMU也在此等待。

进入调试后，先执行了程序第一条指令：
![alt text](figs/image.png)
我们看到程序从CPU复位地址`0x1000`开始执行初始化固件（OpenSBI）的汇编代码，进行最基础的硬件初始化。后续我们继续键入`si`进行单步执行，地址每次递增4,在5条指令过后，地址跳转到了`0x80000000`，在此之前的指令是MROM的固件代码，完成最基本的环境准备，然后 **OpenSBI** 被加载到了`0x80000000`处。
根据实验指导中的提示，为了避免单步调试效率低的问题，我们可以用`watch *0x80200000`命令，这样可以直接观察内核加载，相当于设置了观察点，如果这个点的内容被修改，我们会获得反馈。我们要做的就是执行到这个观察点，直接键入`c`，就可以让程序向下执行，直到执行到了观察点并且修改了这个地址的内容
我们可以在`0x80200000`处设置断点，即执行到此处会停止，命令为`b *0x80200000`，输入`continue`后，得到输出：
![alt text](figs/image2.png)
此时内核暂停在入口函数的第一条汇编指令处，我们可以接着单步执行，观察代码的执行过程：
1. 两步之后，执行到指令`tail kern_init`，它是RISC-V 的尾调用指令，这里用于从 kern_entry 跳转到 kern_init 函数
2. 接着在init过程中执行memset函数，分配.bss数据段
3. 在`0x8020002a`地址处，执行到`cprint`函数
4. 我推测后续执行代码来自于`cprint`函数定义